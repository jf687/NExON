library(devtools)
use_package(matrixcalc)
use_package("matrixcalc")
use_package("Matrix")
devtools::load_all(".")
NExON()
devtools::load_all(".")
NExON()
e_y <- function(Omegas, Ss, Ns, Tn){
sum(sapply(1:Tn,
function(t){
Ns[t] * determinant(Omegas[[t]], logarithm = TRUE)$modulus[1] / 2 -
sum(Ss[[t]] * Omegas[[t]]) / 2
}))
}
devtools::load_all(".")
get_m_zs()
NExON::get_m_zs()
NExON::NExON()
devtools::load_all(".")
NExON::NExON()
View(e_y)
devtools::load_all(".")
NExON::NExON()
devtools::load_all(".")
use_r("NExON_func")
NExON::NExON()
NExON(
)
devtools::load_all(".")
NExON()
NExON()
devtools::document()
NExON::NExON()
use_r(SSL_func)
use_r("SSL_func")
#' @noRd
get_E1 <- function(P, v0, v1) {
bool_log_sum_exp <- F
# logsumexp not suitable for extremes
if (!bool_log_sum_exp) {
ans <- (1 - P) / v0 ^ 2 + P / v1 ^ 2
return(ans)
} else{
tmp <-
matrix(mapply(function(x, y)
effective_sum(c(x, y)), (1 - P) / v0 ^ 2, P / v1 ^ 2), ncol = ncol(P))
return(tmp)
}
# hist(ans - tmp)
}
devtools::load_all(".")
use_r("net_gen")
devtools::load_all(".")
?create_Cn_networks()
?create_Cn_networks()
?create_Cn_networks()
?create_Cn_networks()
use_package("network")
use_package("GGally")
use_package("grid")
m <- matrix(sample(0:1, 25, replace=TRUE), nrow=5)
# Force symmetry
m[lower.tri(m)] <- t(m)[lower.tri(m)]
# Remove self-loops (set diagonal to 0)
diag(m) <- 0
m
devtools::load_all(".")
create_layout(m)
layout <- create_layout(m)
type(layout)
class(layout)
?create_layout
devtools::load_all(".")
?create_layout
m <- matrix(sample(0:1, 25, replace=TRUE), nrow=5)
m[lower.tri(m)] <- t(m)[lower.tri(m)]
diag(m) <- 0
NExON::create_layout(m)
NExON::create_Cn_networks()
sim_data <- NExON::create_Cn_networks()
?NExON
results <- NExON::NExON(sim_data$Ys, ts = (1,2,3,4))
results <- NExON::NExON(sim_data$Ys, ts = c(1,2,3,4))
devtools::load_all(".")
sim_data <- NExON::create_Cn_networks()
results <- NExON::NExON(sim_data$Ys)
ELBO_diff
tol
VN_it
VB_it
maxit
# % # m_deltas
m_deltas <- update_m_deltas(Omegas, m1_alphas, v0s, v1, Tn)
dstars <- get_dstars(m_deltas, v0s, v1)
# % # z
m_zs <- get_m_zs(m_deltas, m1_alphas, Tn)
m2_zs <- get_m2_zs(m_zs, m1_alphas, Tn)
# % # sigma
alpha_sigma <- update_alpha_sigma(a_sigma, P)
beta_sigma <- update_beta_sigma(m2_beta, b_sigma)
m_sig2_inv <- get_m_sig2_inv(alpha_sigma, beta_sigma)
m_log_sig2_inv <- get_m_log_sig2_inv(alpha_sigma, beta_sigma)
# % # zeta
sig2_inv_zeta <- update_sig2_inv_zetaij(t02, P, Tn)
mu_zeta <-
update_mu_zetaij(mu_beta, sig2_inv_zeta, m_zs,ts, n0, t02, P)
m2_zeta <- get_m2_zeta(mu_zeta, sig2_inv_zeta)
# % # beta
sig2_inv_beta <- update_sig2_inv_beta(m_sig2_inv, ts, P)
mu_beta <- update_mu_beta(sig2_inv_beta, m_zs, mu_zeta, ts, Tn)
m2_beta <- get_m2_beta(mu_beta, sig2_inv_beta)
# % #
m1_alphas <- get_m1_alphas(mu_zeta, mu_beta, ts)
var_alphas <- get_var_alphas(sig2_inv_zeta, sig2_inv_beta, ts)
# % #
ELBO <- get_elbo_zetaij(Omegas,
m_deltas,
mu_zeta,
sig2_inv_zeta,
m2_zeta,
alpha_sigma,
beta_sigma,
m_log_sig2_inv,
m_sig2_inv,
m2_beta,
sig2_inv_beta,
m1_alphas,
var_alphas,
dstars,
Ss,
lambda,
v0s,
v1,
n0,
t02,
a_sigma,
b_sigma,
Ns,
P,
Tn)
ELBO
ELBO_diff <- abs(ELBO - ELBO_old)
ELBO_diff
ELBO_old
if (debug && ELBO + eps < ELBO_old) {
warning(paste0(
"Non-increasing in the VB step: ELBO_old = ",
ELBO_old,
", ELBO = ",
ELBO,
'\n'
))
n_warning_VB <- n_warning_VB + 1
}
if (verbose & VB_it %% 5 == 0)
cat(paste0(
"Difference ELBO from previous iteration: ",
format(ELBO_diff),
"\n"
))
ELBO_old <- ELBO
if (debug) {
tmp <- c(tmp, ELBO)
}
devtools::load_all(".")
sim_data <- create_Cn_networks()
results <- create_Cn_networks(sim_data$Ys)
results <- NExON(sim_data$Ys)
create_layout(results$estimates$Omegas[[1]])
layout <- create_layout(results$estimates$Omegas[[1]])
create_network_plots(results$estimates$Omegas, layout_coords = layout)
create_network_plots(sim_data$As, layout_coords = layout)
evaluate_network_list(nets$As, results$estimates$Omegas > 0, 0.5)
evaluate_network_list(sim_data$As, results$estimates$Omegas > 0, 0.5)
evaluate_network_list(sim_data$As, results$estimates$Omegas, 0.5)
conf.mat <- evaluate_network_list(sim_data$As, results$estimates$Omegas, 0.5)
precision(conf.ma)
precision(conf.mat)
precision(conf.mat$conf.mat)
recall(conf.mat$conf.mat)
plot_adjacency_matrices(m)
sim_data <- create_Cn_networks()
v0_list <- select_optimal_v0_t(sim_data$Ys, v0_range = c(0.01,0.02,0.03))
select_optimal_v0_t <- function(Y, v0_range = 10^seq(log10(0.02), log10(0.2), length.out = 30),
plot_ = TRUE, gamma = 0.15, save_outs = F, t_range = seq(0,1, length.out = 1000)) {
list_hyper <- list(lambda = 2,
v0 = 0.5,
v1 = 100,
a = 2,
b = 2,
ar = 1,
br = ncol(Y))
outs <- list()
IC_values <- list()
for (i in seq_along(v0_range)){
v_0_ <- v0_range[i]
print(i)
out <- SSL(Y, list_hyper, set_v0 = v_0_)
IC_values[[i]] <- list()
for(t in seq_along(t_range)){
IC_values[[i]][[t]] <- network_selection_val(t_range[[t]], out$Omega, out$m_delta, Y, gamma = gamma, method = "eBIC")
}
if(save_outs){
outs[[i]] <- out
}
}
IC_values <- matrix(unlist(IC_values), nrow = length(t_range))
opt_v0_ind <- which(IC_values == min(IC_values), arr.ind = T)[[1,2]]
opt_t_ind <- which(IC_values == min(IC_values), arr.ind = T)[[1,1]]
cat("minimum BIC: ", IC_values[opt_t_ind,opt_v0_ind],"\n")
optimal_v0 <- v0_range[opt_v0_ind]
optimal_t <- v0_range[opt_t_ind]
cat("optimal v0 :", optimal_v0,"\n")
cat("optimal t :", optimal_t,"\n")
#v_0 against eBIC values
if(plot_){
plot(v0_range, IC_values[50,], type = "b", log = "x",
xlab = expression(v[0]), ylab = "eBIC",
main = paste("eBIC vs",expression(v[0])),
col = "blue", pch = 19)
abline(v = optimal_v0, col = "red", lty = 2)
legend("topright", legend = paste("Optimal v_0 =", round(optimal_v0, 4)),
col = "red", lty = 2)
}
return(list(optimal_v0=optimal_v0, optimal_t = optimal_t, IC_values = IC_values, outs = outs))
}
v0_list <- select_optimal_v0_t(sim_data$Ys, v0_range = c(0.01,0.02,0.03))
v0_list
v0_list <- select_optimal_v0_t(sim_data$Ys[[1]], v0_range = c(0.01,0.02,0.03))
devtools::load_all(".")
rm(list = c("select_optimal_v0_t"))
NExON:::network_selection_val()
sim_data <- create_Cn_networks()
find_v0_list <- function(Ys){
v0_list <- list()
for(i in 1:length(Ys)){
v0_list[[i]] <- select_optimal_v0_t(Ys[[i]])$optimal_v0
}
return(v0_list)
}
v0_list <- find_v0_list(sim_data$Ys)
layout <- create_layout(sim_data$As[[1]])
create_network_plots(sim_data$As,layout_coords = layout)
results <- NExON(sim_data$Ys, v0_list = v0_list)
create_network_plots(results$Omegas,layout_coords = layout)
create_network_plots(results$m_deltas,layout_coords = layout)
create_network_plots(results$estimates$Omegas,layout_coords = layout)
v0_list
conf.mat <- evaluate_network_list(sim_data$As, results$estimates$Omegas, 0.00001)
precision(conf.mat)
conf.mat <- evaluate_network_list(sim_data$As, results$estimates$Omegas, 0.00001)$conf.mat
precision(conf.mat)
recall(conf.mat)
conf.mat <- evaluate_network_list(sim_data$As, results$estimates$Omegas, 0)$conf.mat
precision(conf.mat)
recall(conf.mat)
conf.mat <- evaluate_network_list(sim_data$As, results$estimates$Omegas, 0.00000001)$conf.mat
precision(conf.mat)
conf.mat <- evaluate_network_list(sim_data$As, results$estimates$Omegas, 0.000000000001)$conf.mat
precision(conf.mat)
conf.mat <- evaluate_network_list(sim_data$As, results$estimates$Omegas, 0.000000000000001)$conf.mat
precision(conf.mat)
conf.mat <- evaluate_network_list(sim_data$As, results$estimates$Omegas, 0.000000000000000001)$conf.mat
precision(conf.mat)
conf.mat <- evaluate_network_list(sim_data$As, results$estimates$Omegas, 0.000000000000000000000001)$conf.mat
precision(conf.mat)
conf.mat <- evaluate_network_list(sim_data$As, results$estimates$Omegas, 0.000000000000000000000000000001)$conf.mat
precision(conf.mat)
m <- Map(function(mat, deltas) {
mat[deltas > 0.5] <- 0   # or TRUE/FALSE if you prefer
mat
}, results$estimates$Omegas, results$estimates$m_deltas)
m[[1]]
m <- Map(function(mat, deltas) {
mat[deltas < 0.5] <- 0   # or TRUE/FALSE if you prefer
mat
}, results$estimates$Omegas, results$estimates$m_deltas)
m[[1]] - results$estimates$Omegas[[1]]
cat(paste0("precision: ",precision(conf.mat)))
cat(paste0("recall: ",recall(conf.mat)))
conf.mat <- evaluate_network_list(sim_data$As,Omegas)$conf.mat
Omegas <- Map(function(mat, deltas) {
mat[deltas < 0.5] <- 0   # or TRUE/FALSE if you prefer
mat
}, results$estimates$Omegas, results$estimates$m_deltas)
# plot the estimated networks with the same layout as the true network plots
create_network_plots(Omegas,layout_coords = layout)
# evaluate the performance of the model by finding the confusion matrix followed by the precision and recall
conf.mat <- evaluate_network_list(sim_data$As,Omegas)$conf.mat
devtools::load_all(".")
# generate simulated networks and data
sim_data <- create_Cn_networks(P = 50, Cn = 4, seed_1 = 252, seed_2 = 123, frac_change = 0.4, Ns_sample = c(150))
# plot the true networks
layout <- create_layout(sim_data$As[[1]])
create_network_plots(sim_data$As,layout_coords = layout)
# perform variable selection (will take time)
v0_list <- find_v0_list(sim_data$Ys,gamma = 0.35, plot_ = FALSE)
# perform network estimation
results <- NExON(sim_data$Ys, v0_list = v0_list)
#Threshold the precision matrices on the PPIs
Omegas <- Map(function(mat, deltas) {
mat[deltas < 0.5] <- 0   # or TRUE/FALSE if you prefer
mat
}, results$estimates$Omegas, results$estimates$m_deltas)
# plot the estimated networks with the same layout as the true network plots
create_network_plots(Omegas,layout_coords = layout)
# evaluate the performance of the model by finding the confusion matrix followed by the precision and recall
conf.mat <- evaluate_network_list(sim_data$As,Omegas)$conf.mat
cat(paste0("precision: ",precision(conf.mat),"\n"))
cat(paste0("recall: ",recall(conf.mat),"\n"))
create_network_plots(results$estimates$Omegas, layout)
out_nets<- lapply(out$estimates$m_deltas, function(x) abs(x)> 0.5)
out_nets<- lapply(results$estimates$m_deltas, function(x) abs(x)> 0.5)
eval_nets <- evaluate_network_list(sim_data$As, out_nets,0.5)
eval_nets <- evaluate_network_list(sim_data$As, out_nets
)
precision(eval_nets$conf.mat)
recall(eval_nets$conf.mat)
#Threshold the precision matrices on the PPIs
estimated_networks <- lapply(out$estimates$m_deltas, function(x) abs(x)> 0.5)
estimated_networks <- lapply(results$estimates$m_deltas, function(x) abs(x)> 0.5)
# plot the estimated networks with the same layout as the true network plots
create_network_plots(estimated_networks,layout_coords = layout)
# evaluate the performance of the model by finding the confusion matrix followed by the precision and recall
conf.mat <- evaluate_network_list(sim_data$As,estimated_networks)$conf.mat
cat(paste0("precision: ",precision(conf.mat),"\n"))
cat(paste0("recall: ",recall(conf.mat),"\n"))
devtools::load_all(".")
# generate simulated networks and data
sim_data <- create_Cn_networks(P = 50, Cn = 4, seed_1 = 252, seed_2 = 123, frac_change = 0.4, Ns_sample = c(150))
# plot the true networks
layout <- create_layout(sim_data$As[[1]])
create_network_plots(sim_data$As,layout_coords = layout)
# perform variable selection (will take time)
v0_list <- find_v0_list(sim_data$Ys,gamma = 0.35, plot_ = FALSE)
# perform network estimation
results <- NExON(sim_data$Ys, v0_list = v0_list)
#Obtain the (binary) network estimates using a PPI of 0.5 for the threshold
estimated_networks <- lapply(results$estimates$m_deltas, function(x) abs(x)> 0.5)
# plot the estimated networks with the same layout as the true network plots
create_network_plots(estimated_networks,layout_coords = layout)
# evaluate the performance of the model by finding the confusion matrix followed by the precision and recall
conf.mat <- evaluate_network_list(sim_data$As,estimated_networks)$conf.mat
cat(paste0("precision: ",precision(conf.mat),"\n"))
cat(paste0("recall: ",recall(conf.mat),"\n"))
